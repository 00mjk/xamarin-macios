<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

	<PropertyGroup>
		<_XamarinTaskAssembly Condition="'$(_PlatformName)' != 'macOS'">$(_XamarinSdkRootDirectory)\tools\msbuild\iOS\Xamarin.iOS.Tasks.dll</_XamarinTaskAssembly>
		<_XamarinTaskAssembly Condition="'$(_PlatformName)' == 'macOS'">$(_XamarinSdkRootDirectory)\tools\msbuild\macOS\Xamarin.Mac.Tasks.dll</_XamarinTaskAssembly>
	</PropertyGroup>

	<UsingTask TaskName="Xamarin.MacDev.Tasks.CompileNativeCode" AssemblyFile="$(_XamarinTaskAssembly)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.LinkNativeCode" AssemblyFile="$(_XamarinTaskAssembly)" />

	<!-- Project types and how do we distinguish between them

									  OutputType   Custom variable
		==================================================================
		iOS Executable Project        Exe
		iOS App Extension Project     Library      IsAppExtension
		iOS Binding Project           Library      IsBindingProject
		iOS Class Library Project     Library

		tvOS Executable Project       Exe
		tvOS App Extension Project    Library      IsAppExtension
		tvOS Binding Project          Library      IsBindingProject
		tvOS Class Library Project    Library

		watchOS App Project           Library      IsWatchOSApp
		watchOS App Extension Project Library      IsAppExtension
		watchOS Binding Project       Library      IsBindingProject
		watchOS Class Library Project Library

		macOS Executable Project        Exe
		macOS App Extension Project     Library      IsAppExtension
		macOS Binding Project           Library      IsBindingProject
		macOS Class Library Project     Library

	-->

	<PropertyGroup>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Exe'">iOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">iOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">iOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'iOS' And '$(OutputType)' == 'Library'">iOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Exe'">tvOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">tvOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">tvOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'tvOS' And '$(OutputType)' == 'Library'">tvOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsWatchOSApp)' != ''">watchOSAppProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsAppExtension)' != ''">watchOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS' And '$(IsBindingProject)' != ''">watchOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'watchOS'">watchOSClassLibrary</_ProjectType>

		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Exe'">macOSExecutableProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library' And '$(IsAppExtension)' != ''">macOSAppExtensionProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library' And '$(IsBindingProject)' != ''">macOSBindingProject</_ProjectType>
		<_ProjectType Condition="'$(_ProjectType)' == '' And '$(_PlatformName)' == 'macOS' And '$(OutputType)' == 'Library'">macOSClassLibrary</_ProjectType>
	</PropertyGroup>

	<PropertyGroup>
		<!-- We must run the linker for executable projects and app extension projects. We must set PublishTrimmed before importing Microsoft.NET.Sdk, because it'll be evaluated there. -->
		<PublishTrimmed Condition="'$(PublishTrimmed)' == '' And ($(_ProjectType.EndsWith ('ExecutableProject')) Or $(_ProjectType.EndsWith ('AppExtensionProject')))">true</PublishTrimmed>

		<!-- App extensions are self-contained, even though their OutputType=Library -->
		<SelfContained Condition="'$(SelfContained)' == '' And $(_ProjectType.EndsWith ('AppExtensionProject'))">true</SelfContained>

		<!-- Add a property that specifies the name of the platform assembly for each platform -->
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'iOS' ">Xamarin.iOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'tvOS' ">Xamarin.TVOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'watchOS' ">Xamarin.WatchOS</_PlatformAssemblyName>
		<_PlatformAssemblyName Condition=" '$(_PlatformName)' == 'macOS' ">Xamarin.Mac</_PlatformAssemblyName>
	</PropertyGroup>

	<Import Sdk="Microsoft.NET.Sdk" Project="Sdk.targets" />

	<!-- Default item includes (globs and implicit references) -->
	<Import Project="Xamarin.Shared.Sdk.DefaultItems.targets" />
	<Import Project="Xamarin.Shared.Sdk.TargetFrameworkInference.targets" />

	<PropertyGroup>
		<_AssemblyFileDiriOS>$(_XamarinSdkRootDirectory)\tools\msbuild\iOS</_AssemblyFileDiriOS>
		<_AssemblyFileDirtvOS>$(_XamarinSdkRootDirectory)\tools\msbuild\iOS</_AssemblyFileDirtvOS>
		<_AssemblyFileDirwatchOS>$(_XamarinSdkRootDirectory)\tools\msbuild\iOS</_AssemblyFileDirwatchOS>
		<_AssemblyFileDirmacOS>$(_XamarinSdkRootDirectory)\tools\msbuild\macOS</_AssemblyFileDirmacOS>
		<_AssemblyFileDir Condition="'$(_PlatformName)' == 'iOS'">$(_AssemblyFileDiriOS)\</_AssemblyFileDir>
		<_AssemblyFileDir Condition="'$(_PlatformName)' == 'tvOS'">$(_AssemblyFileDirtvOS)\</_AssemblyFileDir>
		<_AssemblyFileDir Condition="'$(_PlatformName)' == 'watchOS'">$(_AssemblyFileDirwatchOS)\</_AssemblyFileDir>
		<_AssemblyFileDir Condition="'$(_PlatformName)' == 'macOS'">$(_AssemblyFileDirmacOS)\</_AssemblyFileDir>
	</PropertyGroup>

	<PropertyGroup>
		<_TaskAssemblyName Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">Xamarin.iOS.Tasks.dll</_TaskAssemblyName>
		<_TaskAssemblyName Condition="'$(_PlatformName)' == 'macOS'">Xamarin.Mac.Tasks.dll</_TaskAssemblyName>
	</PropertyGroup>
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CompileExecutable" AssemblyFile="$(_AssemblyFileDir)$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.iOS.Tasks.Mlaunch" AssemblyFile="$(_AssemblyFileDir)$(_TaskAssemblyName)" Condition=" '$(_PlatformName)' != 'macOS' " />

	<!-- Automatically supply project capabilities for IDE use -->
	<ItemGroup>
		<ProjectCapability Include="Apple" />
		<ProjectCapability Include="Mobile" />

		<!-- See https://work.azdo.io/1112733 -->
		<!-- Conflicts with our targets generator in VS+CPS -->
		<ProjectCapability Remove="LaunchProfiles" />
	</ItemGroup>

	<PropertyGroup>
		<!-- Disable symbol stripping for now, since we're not generating the list of symbols to keep yet -->
		<MtouchNoSymbolStrip>true</MtouchNoSymbolStrip>
	</PropertyGroup>

	<!-- Big hack: disable app host verifications -->
	<Target Name="_CheckForUnsupportedAppHostUsage" />

	<!-- Compute a few values -->
	<PropertyGroup>
		<_Is32BitBuild Condition=" '(_Architecture)' == 'x86' Or '$(_Architecture)' == 'ARMv7' Or '$(_Architecture)' == 'ARMv7s' Or '$(_Architecture)' == 'ARMv7k' Or '$(_Architecture)' == 'ARM64_32'">true</_Is32BitBuild>
		<_Is64BitBuild Condition=" '(_Is32BitBuild)' != 'true' ">true</_Is64BitBuild>
	</PropertyGroup>

	<!-- Inject our custom logic into *DependsOn variables -->
	<PropertyGroup>
		<!-- This is somewhat complicated due to how the XI and XM targets differ. This will be improved as things go into master -->
		<_AlwaysPostBuildTargets Condition="'$(_PlatformName)' != 'macOS'">
			_CollectBundleResources;
			_OptimizePngImages;
			_OptimizePropertyLists;
			_OptimizeLocalizationFiles;
			_PackLibraryResources;
			_UnpackLibraryResources;
			_GenerateBundleName;
			_CleanUploaded;
		</_AlwaysPostBuildTargets>
		<_AlwaysPostBuildTargets Condition="'$(_PlatformName)' == 'macOS'">
			_CollectBundleResources;
			_PackLibraryResources;
			_UnpackLibraryResources;
			_GenerateBundleName;
		</_AlwaysPostBuildTargets>

		<_BundleApp Condition="'$(_PlatformName)' != 'macOS'">
			Codesign;
			CreateIpa;
			Archive;
		</_BundleApp>
		<_BundleApp Condition="'$(_PlatformName)' == 'macOS'">
			Codesign;
			_CreateInstaller;
			Archive;
		</_BundleApp>

		<BuildDependsOn>
			$(BuildDependsOn);
			$(_AlwaysPostBuildTargets);
			_CreateAppBundle;
			$(_BundleApp);
		</BuildDependsOn>

		<_PreBundle Condition="'$(_PlatformName)' != 'macOS'">
			_DetectSigningIdentity;
			_CopyResourcesToBundle;
			_CreateAssetPackManifest;
			_SmeltMetal;
			_ForgeMetal;
			_TemperMetal;
			_CompileCoreMLModels;
			_PrepareResourceRules;
			_CompileEntitlements;
			_GetNativeExecutableName;
			_ParseExtraMtouchArgs;
		</_PreBundle>
		<_PreBundle Condition="'$(_PlatformName)' == 'macOS'">
			_DetectSigningIdentity;
			_CopyContentToBundle;
			_SmeltMetal;
			_ForgeMetal;
			_TemperMetal;
			_CompileEntitlements;
		</_PreBundle>

		<_PostBundle Condition="'$(_PlatformName)' != 'macOS'">
			_CompileITunesMetadata;
			_CollectITunesArtwork;
			_CopyITunesArtwork;
			_CreateDebugSettings;
			_CreateDebugConfiguration;
			_CreatePkgInfo;
			_CopyAppExtensionsToBundle;
			_CopyWatchOS1AppsToBundle;
			_CopyWatchOS2AppsToBundle;
			_ReadAppExtensionDebugSymbolProperties;
			_GenerateAppExtensionDebugSymbols;
			_PrepareDebugSymbolGeneration;
			_GenerateDebugSymbols;
			_ValidateAppBundle;
		</_PostBundle>
		<_PostBundle Condition="'$(_PlatformName)' == 'macOS'">
			_CreatePkgInfo;
			_CopyAppExtensionsToBundle;
		</_PostBundle>

		<!-- We re-use ComputeFilesToPublish & CopyFilesToPublishDirectory to copy files to the .app -->
		<!-- ComputeFilesToPublish will run ILLink -->
		<CreateAppBundleDependsOn>
			$(_PreBundle);
			_DetectAppManifest;
			_CompileAppManifest;
			_ComputeLinkerArguments;
			ComputeFilesToPublish;
			_LoadLinkerOutput;
			_CompileNativeExecutable;
			_LinkNativeExecutable;
			_ComputePublishLocation;
			CopyFilesToPublishDirectory;
			$(_PostBundle);
		</CreateAppBundleDependsOn>
	</PropertyGroup>

	<!-- Actual implementations for what we need to do -->

	<!-- Linker -->
	<PropertyGroup>
		<_AdditionalTaskAssemblyDirectory>$(_XamarinSdkRootDirectory)tools/dotnet-linker/</_AdditionalTaskAssemblyDirectory>
		<_AdditionalTaskAssembly>$(_AdditionalTaskAssemblyDirectory)dotnet-linker.dll</_AdditionalTaskAssembly>
	</PropertyGroup>
	<Target Name="_ComputeLinkerSubstitutions">
		<ItemGroup>
			<_LinkerSubstitutions Include="$(_AdditionalTaskAssemblyDirectory)/registerentryassembly.xml" Condition=" '$(_SdkIsSimulator)' != 'True' " />
			<_LinkerSubstitutions Include="$(_AdditionalTaskAssemblyDirectory)/uibutton.xml" Condition=" '$(_IsDebug)' != 'true' " />
		</ItemGroup>
		<PropertyGroup>
			<_LinkerSubstitutionsCommand>@(_LinkerSubstitutions -> '--substitutions %(FullPath)', '%0a')</_LinkerSubstitutionsCommand>
		</PropertyGroup>
	</Target>
	<Target Name="_SelectAssembliesToLink" DependsOnTargets="ComputeResolvedFilesToPublishList">
		<ItemGroup>
			<ResolvedFileToPublish Update="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.Filename)%(ResolvedFileToPublish.Extension)' == '$(_PlatformAssemblyName).dll'">
				<!-- This makes it so that the platform assembly isn't treated as a root assembly -->
				<IsTrimmable>true</IsTrimmable>
			</ResolvedFileToPublish>

			<_AssembliesToLink Include="@(ResolvedFileToPublish.Filename)" Condition="'$(MtouchLink)' == 'full' Or '$(MtouchLink)' == '' " />
			<_AssembliesToLink Include="$(_PlatformAssemblyName)" Condition="'$(MtouchLink)' == 'sdkonly' " />
		</ItemGroup>
	</Target>
	<Target Name="_ComputeLinkerArguments" DependsOnTargets="_ComputeLinkerSubstitutions;_SelectAssembliesToLink;">
		<PropertyGroup>
			<!-- link the core assemblies when using 'sdkonly' also link the platform assembly -->
			<_ExtraTrimmerArgs Condition="'$(MtouchLink)' == 'sdkonly'">$(_ExtraTrimmerArgs) -c link -p link $(_PlatformAssemblyName)</_ExtraTrimmerArgs>

			<!-- we don't want to ignore stuff we can't find -->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --skip-unresolved false</_ExtraTrimmerArgs>

			<!-- add any linker substitution files we might have -->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) $(_LinkerSubstitutionsCommand)</_ExtraTrimmerArgs>

			<!-- Pass the custom options to our custom steps -->
			<_CustomLinkerOptionsFile>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)custom-linker-options.txt'))</_CustomLinkerOptionsFile>

			<!-- The directory where the linker puts *.items files that will be loaded in the _LoadLinkerOutput target -->
			<_LinkerItemsDirectory>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)linker-items'))</_LinkerItemsDirectory>

			<!-- A temporary output directory for our linker steps -->
			<_LinkerCacheDirectory>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)linker-cache'))</_LinkerCacheDirectory>

			<_CustomLinkerOptions>
				AssemblyName=$(AssemblyName).dll
				CacheDirectory=$(_LinkerCacheDirectory)
				ItemsDirectory=$(_LinkerItemsDirectory)
				LinkMode=$(_LinkMode)
				Platform=$(_PlatformName)
				PlatformAssembly=$(_PlatformAssemblyName).dll
				TargetArchitectures=$(TargetArchitectures)
			</_CustomLinkerOptions>
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --custom-data "LinkerOptionsFile=$(_CustomLinkerOptionsFile)"</_ExtraTrimmerArgs>

			<!-- make the output verbose to see what the linker is doing. FIXME: make dependent upon verbosity level -->
			<_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --verbose</_ExtraTrimmerArgs>
		</PropertyGroup>
		<ItemGroup>
			<!-- add our custom steps -->
			<_TrimmerCustomSteps Include="$(_AdditionalTaskAssembly)">
				<BeforeStep>LoadReferencesStep</BeforeStep>
				<Type>Xamarin.SetupStep</Type>
			</_TrimmerCustomSteps>
			<_TrimmerCustomSteps Include="$(_AdditionalTaskAssembly)">
				<!-- At the end of the pipeline -->
				<Type>Xamarin.GenerateMainStep</Type>
			</_TrimmerCustomSteps>
		</ItemGroup>

		<!-- Create the file with our custom linker options -->
		<WriteLinesToFile File="$(_CustomLinkerOptionsFile)" Lines="$(_CustomLinkerOptions)" Overwrite="true" />
	</Target>

	<Target Name="_LoadLinkerOutput">
		<!-- Load _MainFile -->
		<ReadItemsFromFile File="$(_LinkerItemsDirectory)/_MainFile.items" Condition="Exists('$(_LinkerItemsDirectory)/_MainFile.items')">
			<Output TaskParameter="Items" ItemName="_MainFile" />
		</ReadItemsFromFile>
	</Target>

	<!-- Native code -->

	<Target Name="_ComputeVariables" DependsOnTargets="_GenerateBundleName;ResolveRuntimePackAssets">
		<ItemGroup>
			<!-- Look in the ResolvedFrameworkReference for our Microsoft.* package. This should only find a single package. -->
			<_XamarinFrameworkReference Include="@(ResolvedFrameworkReference)" Condition="'%(ResolvedFrameworkReference.Identity)' == 'Microsoft.$(_PlatformName)'" />
		</ItemGroup>
		<PropertyGroup>
			<_IntermediateNativeLibraryDir>$(IntermediateOutputPath)nativelibraries/</_IntermediateNativeLibraryDir>
			<_NativeExecutableName>$(_AppBundleName)</_NativeExecutableName>
			<_XamarinSdkRuntimePackDirectory>%(_XamarinFrameworkReference.RuntimePackPath)</_XamarinSdkRuntimePackDirectory>
			<_XamarinNativeLibraryDirectory>$(_XamarinSdkRuntimePackDirectory)/runtimes/$(RuntimeIdentifier)/native</_XamarinNativeLibraryDirectory>
			<_XamarinIncludeDirectory>$(_XamarinSdkRuntimePackDirectory)/runtimes/$(RuntimeIdentifier)/native</_XamarinIncludeDirectory>

			<_LibMonoLinkMode Condition="'$(_LibMonoLinkMode)' == '' And '$(ComputedPlatform)' != 'iPhone'">dylib</_LibMonoLinkMode>
			<_LibMonoLinkMode Condition="'$(_LibMonoLinkMode)' == ''">static</_LibMonoLinkMode>
			<_LibMonoExtension Condition="'$(_LibMonoLinkMode)' == 'dylib'">dylib</_LibMonoExtension>
			<_LibMonoExtension Condition="'$(_LibMonoLinkMode)' == 'static'">a</_LibMonoExtension>

			<_LibXamarinLinkMode Condition="'$(_LibXamarinLinkMode)' == '' And '$(ComputedPlatform)' != 'iPhone'">dylib</_LibXamarinLinkMode>
			<_LibXamarinLinkMode Condition="'$(_LibXamarinLinkMode)' == ''">static</_LibXamarinLinkMode>
			<_LibXamarinExtension Condition="'$(_LibXamarinLinkMode)' == 'dylib'">dylib</_LibXamarinExtension>
			<_LibXamarinExtension Condition="'$(_LibXamarinLinkMode)' == 'static'">a</_LibXamarinExtension>
			<_LibXamarinName Condition="'$(_LibXamarinName)' == '' And '$(_Debug)' == 'true'">libxamarin-debug.$(_LibXamarinExtension)</_LibXamarinName>
			<_LibXamarinName Condition="'$(_LibXamarinName)' == '' And '$(_Debug)' != 'true'">libxamarin.$(_LibXamarinExtension)</_LibXamarinName>
		</PropertyGroup>

		<ItemGroup>
			<!-- Select the native libraries from mono we need to link with and potentially copy into the app -->
			<_MonoLibrary
				Include="@(ResolvedFileToPublish)"
				Condition=" '%(ResolvedFileToPublish.AssetType)' == 'native' And
							'%(ResolvedFileToPublish.RuntimeIdentifier)' == '$(RuntimeIdentifier)' And
							'%(ResolvedFileToPublish.Extension)' == '.$(_LibMonoExtension)' And
							'%(ResolvedFileToPublish.NuGetPackageId)' == 'Microsoft.NETCore.App.Runtime.$(RuntimeIdentifier)'
							"
			/>
		</ItemGroup>
	</Target>

	<Target Name="_CompileNativeExecutable"
		DependsOnTargets="_DetectSdkLocations;_ComputeTargetArchitectures;_GenerateBundleName;_ComputeVariables;_GetMinimumOSVersion"
		Inputs="@(_MainFile)"
		Outputs="@(_MainFile -> '%(_IntermediateNativeLibraryDir)%(Filename).o')"
		>

		<ItemGroup>
			<_MainFile Update="@(_MainFile)">
				<OutputFile>$(_IntermediateNativeLibraryDir)%(Filename).o</OutputFile>
			</_MainFile>
			<_XamarinMainIncludeDirectory Include="$(_XamarinIncludeDirectory)" />
		</ItemGroup>

		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_IntermediateNativeLibraryDir)" />

		<CompileNativeCode
			SessionId="$(BuildSessionId)"
			CompileInfo="@(_MainFile)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			IncludeDirectories="@(_XamarinMainIncludeDirectory)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
			<Output TaskParameter="ObjectFiles" ItemName="_NativeExecutableObjectFiles" />
		</CompileNativeCode>
	</Target>


	<!-- The .dylibs shipped with mono comes with the original identity:

	$ otool -l ~/.nuget/packages/microsoft.netcore.app.runtime.ios-x64/5.0.0-*/runtimes/ios-x64/native/libSystem.IO.Compression.Native.dylib | grep LC_ID_DYLIB -A 2
          cmd LC_ID_DYLIB
      cmdsize 184
         name /Users/runner/runners/2.165.2/work/1/s/artifacts/obj/native/netcoreapp5.0-iOS-Release-x64/System.IO.Compression.Native/libSystem.IO.Compression.Native.dylib (offset 24)

	This doesn't work after linking with these libraries, so this must be fixed to be @executable_path/. Eventually mono will ship dylibs we don't have to fix (https://github.com/dotnet/runtime/issues/34637).
	-->
	<Target Name="_UpdateDynamicLibraryId" DependsOnTargets="_ComputeVariables" Inputs="@(_MonoLibrary)" Outputs="@(_MonoLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')">
		<!-- install_name_tool modifies the file in-place, so copy it first to a temporary directory before we fix it -->
		<Copy SourceFiles="%(_MonoLibrary.FullPath)" DestinationFolder="$(_IntermediateNativeLibraryDir)" />
		<Exec Command="install_name_tool -id @executable_path/%(_MonoLibrary.Filename)%(_MonoLibrary.Extension) $(_IntermediateNativeLibraryDir)%(_MonoLibrary.Filename)%(_MonoLibrary.Extension)" />
		<!-- Update our item groups -->
		<ItemGroup>
			<_MonoLibraryFixed Include="@(_MonoLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')" />
			<ResolvedFileToPublish Remove="@(_MonoLibrary)" />
			<ResolvedFileToPublish Include="@(_MonoLibraryFixed)" />
			<_MonoLibrary Remove="@(_MonoLibrary)" />
			<_MonoLibrary Include="@(_MonoLibraryFixed)" />
		</ItemGroup>
	</Target>

	<Target Name="_LinkNativeExecutable"
			DependsOnTargets="_DetectSdkLocations;_ComputeTargetArchitectures;_GenerateBundleName;_CompileNativeExecutable;_CompileAppManifest;_UpdateDynamicLibraryId"
			Inputs="@(_NativeExecutableObjectFiles)"
			Outputs="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
		>

		<ItemGroup>
			<_XamarinMainLibraries Include="$(_XamarinNativeLibraryDirectory)/$(_LibXamarinName)" />
			<!-- Link with the libraries shipped with the mono runtime pack -->
			<_XamarinMainLibraries Include="@(_MonoLibrary)" />
			<!-- Hardcode a few frameworks for now -->
			<_NativeExecutableFrameworks Include="Foundation" />
			<_NativeExecutableFrameworks Include="CoreFoundation" />
		</ItemGroup>

		<LinkNativeCode
			SessionId="$(BuildSessionId)"
			Frameworks="@(_NativeExecutableFrameworks)"
			LinkWithLibraries="@(_XamarinMainLibraries)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			ObjectFiles="@(_NativeExecutableObjectFiles)"
			OutputFile="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			WeakFrameworks="@(_NativeExecutableWeakFrameworks)"
		/>

		<ItemGroup>
			<!-- Copy the executable from the intermediate directory to the .app -->
			<ResolvedFileToPublish
				Include="$(_IntermediateNativeLibraryDir)$(_NativeExecutableName)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(MSBuildProjectDirectory)$(_AppBundlePath)))\$(_NativeExecutableName)"/>
		</ItemGroup>
	</Target>

	<Target Name="_ComputePublishLocation" DependsOnTargets="_GenerateBundleName">
		<!-- Put .dll, .pdb, .exe and .dylib in the .app -->
		<PropertyGroup>
			<_AssemblyPublishDir Condition="'$(_PlatformName)' != 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\</_AssemblyPublishDir>
			<_AssemblyPublishDir Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\Contents\MonoBundle\</_AssemblyPublishDir>
			<_DylibPublishDir Condition="'$(_PlatformName)' != 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\</_DylibPublishDir>
			<_DylibPublishDir Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildProjectDirectory)$(_AppBundlePath)\Contents\MonoBundle\</_DylibPublishDir>
		</PropertyGroup>
		<ItemGroup>
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_AssemblyPublishDir)))%(Filename)%(Extension)"
				Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.pdb' Or '$(Extension)' == '.exe'" />
			<ResolvedFileToPublish
				Update="@(ResolvedFileToPublish)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(_DylibPublishDir)))%(Filename)%(Extension)"
				Condition="'%(Extension)' == '.dylib'" />
		</ItemGroup>
	</Target>

	<!-- App bundle creation tasks -->
	<Target Name="_PreAOTCompile" DependsOnTargets="_SetVariables">
		<Copy SourceFiles="@(_AssembliesToAOT)" DestinationFolder="$(_AOTInputDirectory)" />
	</Target>
	<Target Name="_AOTCompile"
			Condition="'$(_SdkIsSimulator)' != 'true' And '$(_PlatformName)' != 'macOS'"
			DependsOnTargets="_SetVariables;_PreAOTCompile;"
			Inputs="@(_AssembliesToAOT)"
			Outputs="@(_AssembliesToAOT->'$(_AOTOutputDirectory)%(Filename)%(Extension).s')">
		<Error Text="Files to AOT (which hasn't been implemented): @(_AssembliesToAOT) " />
	</Target>

	<Target Name="_StripManagedAssemblies" />

	<Target Name="_SetVariables">
		<PropertyGroup>
			<_LibMonoName Condition="'$(_PlatformName)' != 'macOS'">libmono.a</_LibMonoName>
			<_LibMonoName Condition="'$(_PlatformName)' == 'macOS'">libcoreclr.dylib</_LibMonoName>
			<_MonoLibDir Condition="'%(DestinationSubPath)' == '$(_LibMonoName)'">@(RuntimePackAsset -> '%(RootDir)%(Directory)')</_MonoLibDir>

			<_AOTCompiler>$(_MonoLibDir)/cross/mono-aot-cross</_AOTCompiler>

			<_IntermediateNativeLibraryDir>$(IntermediateOutputPath)nativelibraries/</_IntermediateNativeLibraryDir>
			<_AOTInputDirectory>$(_IntermediateNativeLibraryDir)aot-input/</_AOTInputDirectory>
			<_AOTOutputDirectory>$(_IntermediateNativeLibraryDir)</_AOTOutputDirectory>
		</PropertyGroup>
		<ItemGroup>
			<_AssembliesToAOT Include="@(ResolvedFileToPublish)" Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe' ">
				<_AOTOutputDirectory>$(_IntermediateNativeLibraryDir)</_AOTOutputDirectory>
			</_AssembliesToAOT>

			<_NativeDynamicLibrary Include="@(ResolvedFileToPublish)" Condition="'%(Extension)' == '.dylib' And '%(RootDir)%(Directory)' == '$(_MonoLibDir)'" />
			<_NativeDynamicLibrary Update="@(_NativeDynamicLibrary)">
				<LibraryName>$([System.String]::new('%(Filename)').Substring(3))</LibraryName>
			</_NativeDynamicLibrary>
			<_NativeDynamicLibraryPathAll Include="@(_NativeDynamicLibrary -> '%(RootDir)%(Directory)')" />
			<_NativeDynamicLibraryPath Include="@(_NativeDynamicLibraryPathAll->Distinct ())" />
		</ItemGroup>
	</Target>

	<Target Name="_CompileLauncher" DependsOnTargets="_SetVariables;_UpdateDynamicLibraryId">
		<!-- FIXME: Use _NativeDynamicLibrary instead of _NativeDynamicLibraryFixed -->
		<CompileExecutable
			SessionId="$(BuildSessionId)"

			Architecture="$(_Architecture)"
			AppBundlePath="$(_AppBundlePath)"
			AssemblyName="$(AssemblyName)"
			IsAppExtension="$(IsAppExtension)"
			IsDebug="$(_IsDebug)"
			NativeDynamicLibraries="@(_NativeDynamicLibraryFixed)"
			OutputPath="$(_IntermediateNativeLibraryDir)$(_AppBundleName)"
			ResolvedFileToPublish="@(ResolvedFileToPublish)"
			RuntimePackAsset="@(RuntimePackAsset)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		/>
		<ItemGroup>
			<!-- Copy the executable from the intermediate directory to the .app -->
			<ResolvedFileToPublish
				Include="$(_IntermediateNativeLibraryDir)$(_AppBundleName)"
				RelativePath="$([MSBuild]::MakeRelative($(MSBuildProjectDirectory)$(PublishDir),$(MSBuildProjectDirectory)$(_AppBundlePath)))\$(_AppBundleName)"/>
		</ItemGroup>
	</Target>

	<!-- The .dylibs shipped with mono comes with the original identity:

	$ otool -l ~/.nuget/packages/microsoft.netcore.app.runtime.ios-x64/5.0.0-*/runtimes/ios-x64/native/libSystem.IO.Compression.Native.dylib | grep LC_ID_DYLIB -A 2
          cmd LC_ID_DYLIB
      cmdsize 184
         name /Users/runner/runners/2.165.2/work/1/s/artifacts/obj/native/netcoreapp5.0-iOS-Release-x64/System.IO.Compression.Native/libSystem.IO.Compression.Native.dylib (offset 24)

	This doesn't work after linking with these libraries, so this must be fixed to be @executable_path/. Eventually mono will ship dylibs we don't have to fix (https://github.com/dotnet/runtime/issues/34637).
	-->
	<Target Name="_UpdateDynamicLibraryId" DependsOnTargets="_SetVariables" Inputs="@(_NativeDynamicLibrary)" Outputs="@(_NativeDynamicLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')">
		<!-- install_name_tool modifies the file in-place, so copy it first to a temporary directory before we fix it -->
		<Copy SourceFiles="%(_NativeDynamicLibrary.FullPath)" DestinationFolder="$(_IntermediateNativeLibraryDir)" />
		<Exec Command="install_name_tool -id @executable_path/%(_NativeDynamicLibrary.Filename)%(_NativeDynamicLibrary.Extension) $(_IntermediateNativeLibraryDir)%(_NativeDynamicLibrary.Filename)%(_NativeDynamicLibrary.Extension)" />
		<ItemGroup>
			<_NativeDynamicLibraryFixed Include="@(_NativeDynamicLibrary -> '$(_IntermediateNativeLibraryDir)%(Filename)%(Extension)')" />
			<_NativeDynamicLibraryPath Remove="@(_NativeDynamicLibrary -> '%(RootDir)%(Directory)')" />
			<_NativeDynamicLibraryPath Include="@(_NativeDynamicLibraryFixed -> '%(RootDir)%(Directory)')" />
			<ResolvedFileToPublish Remove="@(_NativeDynamicLibrary)" />
			<ResolvedFileToPublish Include="@(_NativeDynamicLibraryFixed)" />
		</ItemGroup>
	</Target>

	<Target Name="Install" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName">
		<Mlaunch
			SessionId="$(BuildSessionId)"
			AppBundlePath="$([System.IO.Path]::GetFullPath('$(_AppBundlePath)'))"
			DeviceName="$(_DeviceName)"
			InstallApp="$([System.IO.Path]::GetFullPath('$(_AppBundlePath)'))"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			ToolsDirectory="$(_XamarinSdkToolsDirectory)"
		/>
	</Target>

	<Target Name="Run" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName">
		<PropertyGroup>
			<!-- capture output by default -->
			<_MlaunchCaptureOutput Condition=" '$(_MlaunchCaptureOutput)' == '' ">true</_MlaunchCaptureOutput>
			<!-- wait for exit by default -->
			<_MlaunchWaitForExit Condition=" '$(_MlaunchWaitForExit)' == '' ">true</_MlaunchWaitForExit>
			<!-- don't set standard output/error path, the task will by default write to stdout/stderr -->
		</PropertyGroup>
		<Mlaunch
			SessionId="$(BuildSessionId)"
			AppBundlePath="$([System.IO.Path]::GetFullPath('$(_AppBundlePath)'))"
			CaptureOutput="$(_MlaunchCaptureOutput)"
			DeviceName="$(_DeviceName)"
			LaunchApp="$([System.IO.Path]::GetFullPath('$(_AppBundlePath)'))"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkVersion="$(_SdkVersion)"
			StandardErrorPath="$(_MlaunchStandardErrorPath)"
			StandardOutputPath="$(_MlaunchStandardOutputPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			ToolsDirectory="$(_XamarinSdkToolsDirectory)"
			WaitForExit="$(_MlaunchWaitForExit)"
		/>
	</Target>

	<!-- Import existing targets -->

	<PropertyGroup>
		<_ProjectLanguage>$(Language)</_ProjectLanguage>
		<_ProjectLanguage Condition="'$(_ProjectLanguage)' == '' Or '$(_ProjectLanguage)' == 'C#' ">CSharp</_ProjectLanguage>
		<_ProjectLanguage Condition="'$(_ProjectLanguage)' == 'F#' ">FSharp</_ProjectLanguage>

		<_TargetsDirectory>$(_XamarinSdkRootDirectory)\tools\msbuild\$(_PlatformName)\</_TargetsDirectory>
	</PropertyGroup>

	<Import Project="$(_TargetsDirectory)Xamarin.iOS.$(_ProjectLanguage).targets"                  Condition="'$(_ProjectType)' == 'iOSExecutableProject' Or '$(_ProjectType)' == 'iOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.iOS.AppExtension.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'iOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.iOS.ObjCBinding.$(_ProjectLanguage).targets"      Condition="'$(_ProjectType)' == 'iOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.$(_ProjectLanguage).targets"                 Condition="'$(_ProjectType)' == 'tvOSExecutableProject' Or '$(_ProjectType)' == 'tvOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.AppExtension.$(_ProjectLanguage).targets"    Condition="'$(_ProjectType)' == 'tvOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.TVOS.ObjCBinding.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'tvOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.$(_ProjectLanguage).targets"              Condition="'$(_ProjectType)' == 'watchOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.App.$(_ProjectLanguage).targets"          Condition="'$(_ProjectType)' == 'watchOSAppProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.AppExtension.$(_ProjectLanguage).targets" Condition="'$(_ProjectType)' == 'watchOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.WatchOS.ObjCBinding.$(_ProjectLanguage).targets"  Condition="'$(_ProjectType)' == 'watchOSBindingProject' " />

	<Import Project="$(_TargetsDirectory)Xamarin.Mac.$(_ProjectLanguage).targets"                  Condition="'$(_ProjectType)' == 'macOSExecutableProject' Or '$(_ProjectType)' == 'macOSClassLibrary' " />
	<Import Project="$(_TargetsDirectory)Xamarin.Mac.AppExtension.$(_ProjectLanguage).targets"     Condition="'$(_ProjectType)' == 'macOSAppExtensionProject' " />
	<Import Project="$(_TargetsDirectory)Xamarin.Mac.ObjCBinding.$(_ProjectLanguage).targets"      Condition="'$(_ProjectType)' == 'macOSBindingProject' " />

	<Target Name="_CompileToNative" /> <!-- sledge hammer approach -->
</Project>
